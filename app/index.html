<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dungeons and Blocks</title>
    <style>
      /* prevent scrollbar feedback loops */
      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden;
        background: #0e0f12;
        color: #e7e7ea;
        font-family: ui-sans-serif, system-ui;
      }

      /* Full-viewport app. Center the game area and size it from JS so it
         aligns with the world pixel grid. */
      #app {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        width: 100%;
        gap: 0;
      }

      /* Phaser canvas is sized to this via RESIZE; we give it explicit W/H */
      #game-root {
        flex: 0 0 auto;
        min-height: 0;
        width: 100%;
        position: relative;
        margin: 0;
      }

      canvas {
        display: block;
        image-rendering: pixelated;
      }

      button {
        background: #2a2f3a;
        color: #e7e7ea;
        border: 1px solid #3a4050;
        padding: 6px 10px;
        border-radius: 8px;
        cursor: pointer;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .mono {
        font-family:
          ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", monospace;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <!-- Phaser mounts here and will auto-resize to fill this area -->
      <div id="game-root"></div>
    </div>

    <script>
      (function () {
        const TILE = 16;

        function getCameraZoom() {
          // Prefer the value the scene writes; fallback to 8 if not ready yet.
          const z = window.__CAMERA_ZOOM__;
          return typeof z === "number" && z > 0 ? z : 8;
        }

        function worldPixel() {
          return TILE * getCameraZoom(); // e.g. 16 * 8 = 128
        }

        function snapGameRoot() {
          const root = document.getElementById("game-root");
          if (!root) return;

          const vpw = Math.floor(window.innerWidth);
          const vph = Math.floor(window.innerHeight);

          const usableW = Math.max(0, vpw);
          const usableH = Math.max(0, vph);

          const PIX = worldPixel();

          // Snap to whole world pixels to prevent jitter when the camera moves.
          const snappedW = Math.max(PIX, Math.floor(usableW / PIX) * PIX);
          const snappedH = Math.max(PIX, Math.floor(usableH / PIX) * PIX);

          root.style.width = snappedW + "px";
          root.style.height = snappedH + "px";

          const offsetX = Math.max(0, Math.floor((usableW - snappedW) / 2));
          const offsetY = Math.max(0, Math.floor((usableH - snappedH) / 2));
          root.style.marginLeft = offsetX + "px";
          root.style.marginRight = offsetX + "px";
          root.style.marginTop = offsetY + "px";
          root.style.marginBottom = offsetY + "px";
        }

        // Re-run snapping if the scene later changes zoom
        const zoomObserver = new MutationObserver(snapGameRoot);
        zoomObserver.observe(document.documentElement, {
          attributes: true,
          subtree: true,
        });

        window.addEventListener("resize", snapGameRoot);
        window.addEventListener("orientationchange", snapGameRoot);
        window.addEventListener("load", () => {
          snapGameRoot();
          // run again shortly after load in case fonts/UI reflow changes layout
          setTimeout(snapGameRoot, 50);
        });

        document.addEventListener("readystatechange", snapGameRoot);

        // Poll a bit during boot while __CAMERA_ZOOM__ becomes available
        let tries = 0;
        const t = setInterval(() => {
          tries++;
          snapGameRoot();
          if (tries > 20) clearInterval(t);
        }, 100);
      })();
    </script>

    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
